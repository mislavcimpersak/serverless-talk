<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Serverless</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/night.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement( 'link' );
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

	<style>
		td.providers, th.providers {
			text-align: center;
			vertical-align: middle;
			font-size: 0.6em;
		}
		ul.no_bullets {
			list-style-type: none;
			padding: 0;
			margin: 0;
			text-align: center;
		}
		li.breathing {
			margin-top: 15px;
			margin-bottom: 15px;
		}
	</style>

</head>
<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h1>Serverless</h1>
				<!-- ovo precrtati pa napisati FaaS? -->
				<h4>⚡ Buzzword of the season ⚡</h4>

				<br>
				<br>

				<ul>
					<li>twitter: <a href="https://twitter.com/MislavCimpersak">@MislavCimpersak</a></li>
					<li>github: <a href="https://github.com/mislavcimpersak">github.com/mislavcimpersak</a></li>
				</ul>

				<aside class="notes" data-markdown>
					- Hello! I'm Mislav, web developer from Zagreb.
					- Primarily Python dev, but lately more and more dabbling with the ops side of my "full stack developer" title.
					- Serverless is something we're all talking about, but only a few actually had a chance to make something.
					- In the past few weeks I took some time to finally play with this fairly new technology so I decided to share with you my experience and experiments.
				</aside>
			</section>

			<section>
				<h2>Serverless</h2>
				<h2>&nbsp;</h2>
				<p>&nbsp;</p>

				<aside class="notes" data-markdown>
					- What is "serverless"?
					- The term on it's own it's a bit apsurd, but it entered our regular IT vocabulary like many other nonsensical terms in IT jargon.
				</aside>
			</section>

			<section>
				<h2 style="text-decoration: line-through;" class="fragment shrink" data-fragment-index="1">Serverless</h2>
				<h2 class="fragment" data-fragment-index="1">FaaS</h2>
				<p class="fragment" data-fragment-index="1">Function-as-a-Service</p>

				<aside class="notes" data-markdown>
					- Serverless doesn't really mean that there are no servers, but that the developers don't have to worry about them.
					- So in essence, at least from the developers point of view, serverless really is without servers.
					- These days most developers aren't writing their code in assembly. Instead they are using modern programming languages that know on their own how to properly use CPU, memory, network resources, stored data.
					- Serverless takes this even one step further, apstracting another layer - infrastructure.

					- Developers build small blocks of code - functions - which are invoked when needed.
					- When a function is invoked, platform on which the function is stored starts resources needed for execution and returns result.
					- Such functions can be chained and interlinked to create complex applications.
					- Each function is then called if and when needed, depending of application logic.
					- Rest of the time, the function is not using any resources.

					- So, if we observe serverless from the point of simple functions we get to a better name, and that is Function-as-a-Service.
				</aside>
			</section>

			<section>
				<h2>Providers</h2>

				<table>
					<tr>
						<th class="fragment providers" data-fragment-index="1" width="33%">AWS Lambda</th>
						<th class="fragment providers" data-fragment-index="10" width="33%">Azure Functions</th>
						<th class="fragment providers" data-fragment-index="10" width="33%">Google Cloud Functions</th>
					</tr>
					<tr>
						<td class="fragment providers" data-fragment-index="1"><img width="100px" src="media/aws_lambda_logo.png"></td>
						<td class="fragment providers" data-fragment-index="10"><img width="100px" src="media/azure_functions_logo.png"></td>
						<td class="fragment providers" data-fragment-index="10"><img width="100px" src="media/google_cloud_functions_logo.png"></td>
					</tr>
					<tr>
						<td class="fragment providers" data-fragment-index="20">JS, PY, Java, C#</td>
						<td class="fragment providers" data-fragment-index="20">JS, PY, C#, F#, PHP, Batch, PowerShell</td>
						<td class="fragment providers" data-fragment-index="20">JS</td>
					</tr>
					<tr>
						<td class="fragment providers" data-fragment-index="30">S3, SNS, SES, DynamoDB, Kinesis, CloudWatch, Cognito, API Gateway, CodeCommit ...</td>
						<td class="fragment providers" data-fragment-index="30">Cloud Pub/Sub or Cloud Storage Object Change Notifications</td>
						<td class="fragment providers" data-fragment-index="30">Blob, EventHub, Generic WebHook, GitHub WebHook, Queue, Http, ServiceBus Queue, Service Bus Topic, Timer triggers</td>
					</tr>
				</table>
				<p style="text-align: left; font-size: 0.7em;" class="fragment"><a href="https://cloudacademy.com/blog/microsoft-azure-functions-vs-google-cloud-functions-fight-for-serverless-cloud-domination-continues/">*detaljnija usporedba</a></p>

				<aside class="notes" data-markdown>
					- AWS's Lambda is the most famous Function-as-aservice provider.
					- Most of the blog posts you can find online talks about it.
					- But, as it expected, there are equivalent solutions on other cloud providers.

					- Microsoft has Azure Functions and Google has Google Cloud Functions.
					- Aproximately same set of programming languages are supported by AWS and Azure, while Google only supports JS.
					- All three provides allow same free tier of 1M monthly requests for all functions per account.

					- All providers are tightly integrated in their platforms. And thus acordingly the triggers that can run a function are regulary with the provider's ecosystem.
					- The obvious exception is HTTP traffic that is a common trigger for all of them.
				</aside>
			</section>

			<section data-background-image="media/sailboats.jpg">
				<h2>Advantages</h2>

				<aside class="notes" data-markdown>
					- Before I continue talking about advantages I must confess that I'm currently in a honeymoon phase with FaaS.
					- Everything is beautiful and dandy, and everything that is not so great I'm not seeing as such a bad thing.
				</aside>
			</section>

			<section>
				<h2>Idea to launch</h2>

				<aside class="notes" data-markdown>
					- Time to launch is by far the biggest and most important benefit.
					- Let's say you have an idea and you wan't to show it to the world as soon as possible.
					- The usual steps for it are:
					- the idea itself, writing code, buying a server, installing OS, installing web server, installing WSGI server, setting up supervisor, setting up firewall, setting up backup, and 10 more tasks like that and only than launch.
					- And honestly, the only thing that is of any interest to you as a developer (especially for a side project) is idea, writing code and publishing your creation.
					- Anything else can be someone else's problem.
					- Which leads us to the second advantage:
					- Što nas vodi do druge prednosti:
				</aside>
			</section>

			<section>
				<h2>No system administration</h2>

				<aside class="notes" data-markdown>
					- In a completely serverless architecture there is no need for a sys admin.
					- There are no bash scripts, starting and stoping services and things like that.
					- Only thing that is necessary is writing the code, packaging it and uploading it to a FaaS platform.
				</aside>
			</section>

			<section>
				<h2>Automatic scaling</h2>

				<aside class="notes" data-markdown>
					- We don't have sys admins, but we do have scaling.
					- Once you have written your function, suddenly you have thousands of them at your disposal that are sleeping and just waiting to complete a task you provide them and all that withing microseconds from activation.
					----
					- Of course, scaling works both ways.
					- Why pay for servers when you are not using them.
					- You only pay for executions, not the server's idle time.
				</aside>
			</section>

			<section>
				<h2>Parallelization</h2>

				<aside class="notes" data-markdown>
					- Parallelization is linked to automatic scaling, but it's still different.
					- Not only that you have at your disposal hundreads of functions that are waiting for your task, but you have hundreads functions that can do the same task at the same time.
					- example:
					- Let's say that we have a document store database in which we are writting articles.
					- And now we want to add or remove some data on all articles.
					- The usual way to be to write a script that would go through all articles one by one and edit them.
					- We have 50.000 articles and it takes 1 second to edit an article. That's a bit less than 14 hours for 50.000 articles.
					- If we take into consideration that the current limit on AWS's Lambda is 1000 concurrent executions, with the help of a bit smarter script we can start 1000 Lambda functions and get all the work done under a minute.
				</aside>
			</section>

			<section>
				<h2>Change in mindset</h2>

				<aside class="notes" data-markdown>
					- "Change in mindset" is a bit less tangible advantage, but quite important for today's applications.
					- FaaS incourages creating small parts, loosely conected.
					- Unix philosophy and Unix way of thinking - problems are easier to solve if they are broken into smaller pieces.
					- FaaS as such perfectly fits and encourages microservices architecture.
				</aside>
			</section>

			<section data-background-image="media/dried_mud.jpg">
				<h2>Disadvantages</h2>

				<aside class="notes" data-markdown>
					- Of course, not everyting is so great.
					- There are flaws.
				</aside>
			</section>

			<section>
				<h2>Vendor lock in</h2>

				<aside class="notes" data-markdown>
					- Unfortunately all the top vendors have their own closed and specific solely to them implementation.
					- There are in some projects attempts to create abstractions layers that should combat this problem and make it possible to run the code on any provider.
					- But, for now it's all more in the "attempt phase", than a proper out-of-the-box solution.
				</aside>
			</section>

			<section>
				<h2>Cold start</h2>

				<p style="font-size: 0.8em;">
					<a href="https://read.acloud.guru/does-coding-language-memory-or-package-size-affect-cold-starts-of-aws-lambda-a15e26d12c76">*thorough analysis</a>
				</p>

				<aside class="notes" data-markdown>
					- Pod prednostima sam naveo da funkcije kada se ne koriste se "ugase" što je dobra stvar. Loša stvar je da im je za ponovno paljenje inicijalno potrebno nešto više vremena.
					- AWS ubija funkcije nakon više od 5 minuta neaktivnosti. Ponekad je to pola sata, a ponekad 5 minuta i 2 sekunde. Zašto ubija točno kada ubija, to samo Amazon zna.
					- Mi Python developeri imamo ovdje sreće, jer se kod Pythona i dalje radi o par sekundi, dok se Java i C# developeri trebaju pripremiti i na 100 puta dulji start.
					- Dao sam ovdje link na blog post u kojemu jedan developer podosta ekstenzivno radi usporedbe, zanimljivo pogledati ako zbog ničeg drugoga onda da vidite kako nam je lijepo što radimo s Pythonom.
					- Povećanjem memorije koju date funkciji smanjujete vrijeme hladnog paljenja
					- začuđujuće, veličina paketa ne utječe na vrijeme hladnog paljenja
				</aside>
			</section>

			<section>
				<h2>Maturity</h2>

				<aside class="notes" data-markdown>
					- serverless as an idea exist only for the past 3 years.
					- Thigs are still chaning, often in the background without any explanation from vendors.
					- New functionalitis are slowly introduced (Google still only supports only JS, AWS Lambda can't be triggered from Simple Queue Service events...)
					- Debugging is problematic, it's often try-and-error based.
				</aside>
			</section>

			<section data-background-image="media/helicopters_deployment.jpg">
				<h2>Deployment</h2>

				<aside class="notes" data-markdown>
					- iskreno, može se sve napraviti ručno, preko AWS management console, ali nemojte, nepotrebno si komplicirate život.
					- ako ste obrisali funkciju, obrisali ste i sve postavke vezane za nju, ako koristite alate onda sve postavke imate u version control sustavu i lako napravite ponovni deploy.
					- također, podešavanje API gatewaya nikad nije nikome stavilo osmijeh na lice
				</aside>
			</section>

			<section>
				<ul class="no_bullets" style="text-align: left;">
					<li>
						<a href="https://aws.amazon.com/cli/">AWS CLI</a>
						<pre class="fragment" style="width: 110%;" data-fragment-index="15"><code data-trim data-noescape>
							aws lambda update-function-code --function-name
							arn:aws:lambda:region:your-lambda-function
							--zip-file fileb://dist/function.zip --publish
						</code></pre>
					</li>
					<li class="fragment" data-fragment-index="20">
						<a href="https://serverless.com/">Serverless</a>
						<pre class="fragment" data-fragment-index="25"><code data-trim data-noescape>
							serverless deploy
						</code></pre>
					</li>
					<li class="fragment" data-fragment-index="20">
						<a href="https://github.com/aws/chalice">Chalice</a>
						<pre class="fragment" data-fragment-index="25"><code data-trim data-noescape>
							chalice deploy
						</code></pre>
					</li>
					<li class="fragment" data-fragment-index="20">
						<a href="https://github.com/Miserlou/Zappa/">Zappa</a>
						<pre class="fragment" data-fragment-index="25"><code data-trim data-noescape>
							zappa deploy prod
						</code></pre>
					</li>
				</ul>

				<aside class="notes" data-markdown>
					- Za početak tu je AWS-ov command line interface.
					- nije veliki korak naprijed od ručnog podešavanja, pogotovo kada shvatite koja kobasica je potrebna za inicijalni deployment

					- zato su se i razvila tri alata koji olakšavaju cijelokupni deployment i update
					- Serverless je toolkit za postavljanje serverless arhitekture.
					- Razvijan kao alat za JS, Python, Javu i C#.
					- Trude se biti i platform agnostic, ali je na žalost na trenutke to nemoguće zbog samih providera.

					- Chalice je razvio AWS i reklamira ga kao "Python Serverless Microframework"
					- slično kao i Flask koristi dekoratore za rute
					- u potpunosti je orijentiran na serverless i minimalizam i daje jednostavno cli sučelje prema Lambdi
					- preporuka ako imate u glavi nešto brutalno jednostavno s jednim ili dva API pointa
					- sve u svemu, dobar alat

					- Zappa je nastala kao ideja da se omogući deployanje WSGI appova na Lambdu.
					- Razmišljajte u okvirima Djanga, Flaska, Bottlea, novog APIStara i sličnih.
					- Zappa sama podesi API Gateway tako da kada dođe request Gateway pokrene Lambda funkciju.
					- Funkcija prima request i obrađuje ga.
					- Kada funkcija obavi svoje, response se šalje opet kroz API Gateway i dalje do klijenta.

					- Zajedničko svima trima je jednostavnost.
					- Odaberite alat koji vama ima najviše smisla za vaše potrebe.
				</aside>
			</section>

			<section>
				<img src="media/xkcd_uploading_to_aws.png" alt="">

				<aside class="notes" data-markdown>
					- inače, kada lupite `deploy` ili `update` je trenutak u kojemu počinjete shvaćati brzinu uploada koju imate kod kuće
					- dobra stvar je da deployment ne čini funkciju nedostupnom, već kada se sljedeća instanca starta, starta se s novim kodom.

					- Meni se osobno najviše sviđa Zappa, pa sam stoga i s njom složio sljedeće primjere.
				</aside>
			</section>

			<section data-background-image="media/space.jpeg">
				<h2>Examples</h2>

				<aside class="notes" data-markdown>
					- Kada sam prije par dana počeo pripremati talk za ovaj Meetup razmišljao sam kakav primjer bi pokazao.
					- Htio sam vam pokazati nešto dovoljno zanimljivo, a opet ne prekomplicirano da sebi ne zagorčam život.
					- I sjetio sam se jedne zafrkancije od prije par mjeseci.
					- Ideja koja je stajala sa strane baš iz razloga jer mi se nije samo zbog toga plaćati hosting i podešavati server.
					- Iskreno, jedino što mi se dalo je napisati 20-30 linija koda i pustiti tu zafrkanciju van.
				</aside>
			</section>

			<section>
				<h2>@realGrickiTop</h2>

				<div class="fragment" data-fragment-index="1">
					<a href="https://twitter.com/realGrickiTop">twitter.com/realGrickiTop</a>
				</div>
				<img class="fragment" data-fragment-index="1" src="media/realGrickiTop.png" alt="">

				<aside class="notes" data-markdown>
					- a ta zafrkancija je bila "realGričkiTop".
					- Twitter account koji poput i "realDonaldTrump" accounta svaki dan očekivano točno u podne tweeta gluposti.
				</aside>
			</section>

			<section>
				<div>
					<h4 style="text-align: left; font-size:0.8em;">main.py</h4>
					<pre><code data-trim data-noescape>
def post_tweet(event, context):
  poster = Poster()
  poster.post()
					</code></pre>
				</div>
				<div class="fragment" fragment-data-index="1">
					<h4 style="text-align: left; font-size:0.8em;">zappa_settings.json</h4>
					<pre><code data-trim data-noescape>
{
  "prod": {
    "aws_region": "eu-central-1",
    "s3_bucket": "realgrickitop",
    "remote_env": "s3://realgrickitop/secrets.json",
    "apigateway_enabled": false
  }
}
					</code></pre>
				</div>

				<div class="fragment" fragment-data-index="2">
					<h4 style="text-align: left; font-size:0.8em;">shell</h4>
					<pre><code data-trim data-noescape>
zappa deploy prod
zappa invoke prod 'main.post_tweet'
					</code></pre>
				</div>

				<aside class="notes" data-markdown>
					- Za prvu verziju stvar je bil poprilično jednostavna.
					- Napisao sam tridesetak linija koda koje su se svele na poziv moje custom metode za postanje tweeta.
					- Složio sam i bazični `zappa_settings.json` file.
					- `aws_region` je dovoljno da je samo jedan, može se deployati i globalno, ali za ovaj primjer nema smisla.
					- `secrets.py` je "flat" json file u kojemu su zapisani svi credentialsi i on je hostan na S3 bucketu.
					- Tako ovaj kod može biti i open sourcean.

					- Budući da je ovo funkcija koja ne treba biti dostupna preko HTTP-a, onemogućio sam API Gateway.
					- I na koncu sam deployao na lambdu.
					- Zappa ima posebnu komandu kojom se može pozvati bilo koja funkcija na Lambdi za lako testiranje
					- i sve je radilo savršeno
				</aside>
			</section>

			<section>
				<ul>
					<li class="breathing">AWS servers on UTC</li>
					<li class="fragment breathing">Live debugging</li>
					<li class="fragment breathing">Zappa packages everything</li>
				</ul>

				<aside class="notes" data-markdown>
					- And than the problems started.
					- The biggest was that the tweet had to be sent every day at noon.
					- In Croatia.
					- AWS servers are on UTC time, and well, Croatia is not.
					- Setting up time zone aware scheduler which takes into account daylight saving hours is apsurd.
					- Debugging is a hit and miss.
					- Zappa created unnecessarily large .zip files. Why? No idea.
					- It goes though site-packages dir and just adds everything, from pep8 package, pytest, coverage, jupyter,... everything.
					- The solution is to write a really long list of excludes.
					- And than again try-and-error to see if the function is still working.
				</aside>
			</section>

			<section>
				<h2>XKCD Excuse Generator</h2>

				<div class="fragment" data-fragment-index="1">
					<a href="https://zhrx77k67l.execute-api.eu-central-1.amazonaws.com/prod/blank"><code>/blank</code></a>
				</div>
				<img class="fragment" data-fragment-index="1" src="media/xkcd_blank_excuse.png" alt="">

				<aside class="notes" data-markdown>
					- Ideja za drugi primjer je došla dok sam pripremao ovaj talk.
					- Uzima ovu praznu sliku i pretvara ju u sliku sa željenim izgovorom.
					- Sada možemo kliknuti na ovaj link i isprobati stvari u browseru.
						- "my dependencies are installing"/"deps"
						- "my docker image is building"/"building"
				</aside>
			</section>

			<section>
				<pre style="width: 110%;"><code data-trim data-noescape>
app = Flask(__name__)

@app.route('/blank', methods=['GET'])
def blank():
  with open(os.path.join(dir_path, 'blank_excuse.png'), 'rb') as blank:
	return send_file(BytesIO(blank.read()),
	  attachment_filename='blank_excuse.png', mimetype='image/png')


@app.route('/', methods=['GET'])
def root():
  ...

if __name__ == "__main__":
  app.run(host='0.0.0.0')
				</code></pre>

				<aside class="notes" data-markdown>
					- U osnovi to je obični Flask app
					- Štos je da serviram generirane slike direktno iz Lambde.
					- Slike nikad nisu spremljene, a da jesu, trebale bi biti na S3, pa bi onda u idealnom svijetu imao i neki cache ispred toga i tako dalje...
					- Uglavnom, bar pola sata više posla :D
					- A i ovako mi sve ostaje unutar troškova Lambde.
				</aside>
			</section>

			<section>
				<pre><code data-trim data-noescape>
{
  "prod": {
  	"app_function": "app.app",
  	"aws_region": "eu-central-1",
  	"profile_name": "mislavcimpersak",
  	"s3_bucket": "excuse-generator"
  },
  "dev": {
  	"extends": "prod",
  	"debug": true
  }
}
				</code></pre>

				<aside class="notes" data-markdown>
					- With this example I've toyed a bit more and even at some point send the URL to some people.
					- Because of it I couldn't just edit and test existing function.
					- So here I took Zappa's advantage of creating several deploy stages.
				</aside>
			</section>

			<section>
				<ul>
					<li class="breathing">Image serving</li>
					<li class="fragment breathing">IOpipe monitoring and WSGI apps</li>
				</ul>

				<aside class="notes" data-markdown>
					- Dosta ručne zafrkancije je potrebno za serviranje slike direktno.
					- Vjerojatno se to još može optimizirati, ali budući da je složeno za manje od sat vremena sam zadovoljan.
					- na žalost IOpipe koji mi je bio izvrstan za monitoring non-WSGI funkcija ne radi za WSGI app-ove.
					- Trenutno je razvoj python plugina "na pauzi".
					- Šteta jer je IOpipe realno jedini specijalizirani monitoring FaaS-ova.
				</aside>
			</section>

			<section data-background-image="media/wrap_up.jpeg">
				<h2>Wrap up</h2>

				<aside class="notes" data-markdown>
					- FaaS is fantastic for microservices
					- but don't go crazy and plan your whole architecture on serverless.
					- Yes, I've seen such examples.
					- If you have some mini project or you can take out a piece of your system, go for it.
					- Embrace Function-as-a-Service state of mind as soon as possible; FaaS is here to stay.
				</aside>
			</section>

			<section>
				<ul>
					<li class="breathing"><a href="https://mislavcimpersak.github.io/serverless-talk/">mislavcimpersak.github.io/serverless-talk</a></li>
					<li class="breathing"><a href="https://github.com/mislavcimpersak/realGrickiTop">github.com/mislavcimpersak/realGrickiTop</a></li>
					<li class="breathing"><a href="https://github.com/mislavcimpersak/xkcd-excuse-generator">github.com/mislavcimpersak/xkcd-excuse-generator</a></li>
				</ul>
			</section>
		</div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
		// More info https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			history: true,
			transition: 'fade',

			// More info https://github.com/hakimel/reveal.js#dependencies
			dependencies: [
			{ src: 'plugin/markdown/marked.js' },
			{ src: 'plugin/markdown/markdown.js' },
			{ src: 'plugin/notes/notes.js', async: true },
			{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
			]
		});
	</script>
</body>
</html>
